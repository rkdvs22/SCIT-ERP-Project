# Javascript 언어적 특징


# 개요

  * 넷스케이프가 단기간에 완성한 언어로 web을 구축하는 HTML,CSS와 함께 3대 구성요소이다.
  (웹페이지의 동작을 담당한다.)

  * 브랜든 아이크가 10일이라는 짧은 기간내에 만들었기 때문에 타언어와는 다르게 미흡한 부분이 많다.
  
    * 일종의 안전 장치가 없다. 
    (정확하게 컴파일하거나 오류를 체크해주지 않음. - 치명적이지 않은 이상 돌아감)
    
    * 블럭 단위의 스코프가 아닌 기본적으로 영역의 범위는 함수 단위의 Scope이다. (최근에 개선됨 - 이전엔 "use strict";로 전역변수에 대한 접근을 방지)

    * 변수의 접근은 호이스팅을 기본원리로 한다.

    * 모듈화를 미지원한다. (최근에 개선됨)

    * 상속의 개념에 대응하기 위해 class가 아닌 prototype을 사용한다. (최근 class생김)

    * 클로저 및 콜백 등 함수를 일급객체로 사용하여 여러가지 접근 방법이 가능하다. 
    (자바가 class, method를 나눠 서로 퍼즐 맞추듯이 하는 언어라면 자바스크립트는 함수를 그렇게 사용)

    * 특정 변수에 대해 타입을 정적으로 선언하지 않고 들어오는 변수에 맞춰 동적으로 사용한다. 

  * 자바스크립트의 흐름 

    * 자바스크립트는 원래는 웹페이지의 구조를 제어하고 이벤트를 관리하는 용도로서만 쓰였지만 최근의 웹페이지는 이전 정적웹페이지와는 다르게 동적페이지를 지향하고 있고 HTTP 2.0, HTML5등 점차 웹의 성능과 환경이 좋아지며 Ajax를 통한 비동기 방식이 각광받으며 자바스크립트가 주목받게 되었다

    * 특유의 유연함과 함수지향의 특징 등으로 인해 다채롭고 자유로운 프로그래밍이 가능하며 최근은 트랜스파일러인 babel등으로 인해 더이상 브라우저가 지원하지 않아도 사용할 수 있게 환경이 개선되고 있다.

    * 더이상 프론트앤드, 웹에서만 사용하는 언어가 아닌 서버를 구축하고 관리하는 백앤드, 그리고 다른 소프트웨어에서도 사용할 수 있을만큼 가능성이 높은 언어이다.

  * 자바스크립트의 구조

    * DOM : Data Object Model의 약자로 document객체에 대한 값들이 저장되어 있다.
    HTML, XML문서의 프로그래밍 인터페이스로 이전 JQuery는 이러한 DOM을 간단하게 조작하여 빠르고 쉽게 프로그래밍을 하였다.  쉽게 말해서 윈도우에 로드된 문서를 의미한다.
        * (ex - document.getElmentById("");)

    * BOM : Browser Object Model의 약자로 웹 브라우저 창을 관리할 목적으로 제공되는 객체모음이다. - 즉 브라우저 제공사마다 조금씩 다르다.
        * window 객체
        * Navigator
        * Screen
        * location
        * Frame
        * history
        * XMLHttpRequest
    
    * ECMA Script : 우리가 흔히 말하는 자바스크립트에 해당하며 표준 스크립트이다. 
    버전은 다음과 같다.

        * ES3(1999) 
        = 대중들이 많이 아는 버전으로 대표적 특징으로는 다음과 같다.
            * 함수 단위의 스코프
            * 호이스팅
            * 모듈화 미지원
            * 프로토 타입
        
        * ES5 (2009)
        = 현재 일본에서 주로 쓰고 있는 버전으로 새로운 기능은 다음과 같다.
            
            * 배열 
            = 배열과 관련해서 새로운 메소드들이 추가됨
                * ex)forEach, map, filter, reduce, some, every (위의 4개는 반드시 알아두자 - 실수를 줄여줌)
            
            * 객체
            = 객체의 프로퍼티에 설정을 할 수 있게되었다
                * 객체.create(), 객체.freeze(), 객체.assign(), 객체.getter/setter()객체.defineProperty() 객체.keys 메서드
                
            * strict 모드
            = 전역변수를 더럽히지 않고 문서를 좀 더 안전하게 작성할 수 있게 되었다.

            * bind() 메서드
            = this를 강제로 bind시켜주는 메서드

            * JSON(Javascript Object Notation)
            = 과거는 주로 데이터를 XML로 주고 받았다.
            (불편하고 무거움)이를 대체하기 위해 자바스크립트 객체처럼 키와 벨류로 묶어서 보내는 방식인 JSON이 대세가 되었다.
            보낼때는 객체를 String화 해서 보내야 하기 때문에 JSON.stringify(obj)방식,
            받을때 스트링을 객체로 파싱할 때는 JSON.parse(jsonFile)로 주고 받는다.

        * ES2015(ES6 -2015년)
        = Javascript의 여러 문제들을 해결했다. 현재 한국, 미국 등 도입이 빠른 국가들이 사용하고 있으나 여러 브라우저(특히 IE)에서 지원하지 않기 때문에 이전 버전으로 코드를 바꿔주는 Babel이란 것을 사용해서 프로그래밍을 하고 있다. 주요 특징은 다음과 같다.

            * 호이스팅이 사라진 것 같은 효과
            * 함수 단위 스코프에서 {} 블록 단위 스코프
            * this를 동적으로 바인딩하지 않는 = > function
            ```
            const b = () => {
                // 애로우 펑션은 strict mode 여부에 상관없이 Window

                // 전역에서 this가 Window이기 때문에 상속받는 것임.
            console.log(this); // Window

            };

            b();

            ```
            * 모듈화 지원
                * ECMA5까지는 모듈사용에 관해서 표준이 없었다.(다른 스크립트 언어 - 루비, 파이썬 등등 모두 존재) → 
                
                * Node.js를 사용하는 유저들은 module.export를 통해 모듈을 정의하고 require() 함수를 통해 모듈을 불러와서 사용했는데 이러한 방식을 CommonJS라 불렸다. var module = require(”)
                
                * 이에 비해 프론트 영역은 전혀 모듈을 제어하는 방법이 없었고 <script src></script>방법을 사용해서 관리했다. 
                
                * 점차 프론트 영역의 크기가 방대해짐에 따라 서로 다른 모듈을 효율적으로 관리하고 서로간의 의존성, 관계에 따라 변수에 접근, 리소스를 전송해야 하는 작업이 많아졌고 모듈을 제어하는 방법이 필요하게 되었다. (제어하는 방법이 없을때 단순히 <script src></script>를 이용해서 제어한다면 페이지가 로딩될 때 모든 JS는 해당 브라우저의 window객체이므로 만약 어딘가 변수명이 일치할 시 의도치 않게 해당변수에 접근하게 되고 이로인해 전혀 다른 결과를 얻을 수 있다. - 이를 막기 위해 즉시실행함수와 모듈패턴으로 관리했으나 비효율적이고 어려움..)
                
                * 그리하여 모듈을 효율적으로 관리하기 위해 AMD, CommonJS방식 등의 모듈 규칙이 생기게 되었다. 단 대표적인 이 2가지 방식은 모두 비동기 방식이기 때문에 한계점이 많았다. 
                
                * 만약 다른 페이지로 이동할 시 수십개의 JS를 로드하는 등 부하를 증가시켜 프로그램의 성능을 악화시키는 결과를 초래했다.(페이지를 로딩할 시 동적로딩을 하면서 아래에서부터 차례대로 수십, 수백개의 JS가 로드된다..) 
                
                * 이러한 단점을 해결하기 위해 번들링을 할 필요가 있었다. (위의 AMD.CommonJS 등등의 규칙을 기준으로 모듈간 의존성을 판단하여 1개의 단일 파일화 시키는 것) 
                
                * 이런한 번들링을 처리하기 위해 여러가지 번들러가 생겼지만  그 중에서도 webpack이라는 번들러가 가장 인기가 많고 많이 사용되고 있다.(간단, 오류가 적음, 관련 정보가 많음) 

                * 현재는 이 번들링된 단일 JS를 AMD, CommonJS, ECMA2015(ES6) 모듈 제어 기준을 적용해서 모듈을 관리하고 있다. → 가장 쉽고 많이 쓰이는 것은   ECMA2015(ES6)의 import문이다. 

                * 대표적인 모듈 제어 기법 3가지 
                    * AMD방식 : 
                    require([“], function(module) {})

                    * CommonJS방식(Node.js방식) :  
                    var module = require(”)

                    * ECMA2015(ES6)방식 : 
                    import { module } from “;
                
                * 자바스크립트 모듈화 및 모듈제어는 아직 과도기적이기 때문에 아직 어떻게 변할지 정확히 알 수는 없으나 가능하다면 ECMA2015(ES6)과 CommonJS방식에 대해서는 알아두자 특히 ECMA2015(ES6)는 표준이며 AMD,CommonJS를 혼용해서 사용할 수 있기 때문에 꼭 알아두자..
        
            * Promise기능 추가 (이전 버전에 비해 모듈화 다음으로 개선된 점)

                * 이전 자바스크립트에서 비동기 프로그래밍 방식인 콜백을 사용하다 보면 콜백이 중첩되면서 피라미드형의 중첩되는 함수형태를 볼 수 있다.. 

                ```
                    step1(function (err, value1) {
                    if (err) {
                        console.log(err);
                        return;
                    }
                        step2(function (err, value2) {
                            if (err) {
                                console.log(err);
                                return;
                            }
                            step3(function (err, value3) {
                                if (err) {
                                    console.log(err);
                                    return;
                                }
                                step4(function (err, value4) {
                                    // 정신 건강을 위해 생략
                                });
                            });
                        });
                    });

                ```

                * 콜백지옥이 일어나는 이유는 무엇? 

                    * 위에 처럼 어떤 함수가 실행되면 어떤 함수가 실행되고.. 이렇게 이벤트에 결과에 따라 순서대로 다른 함수가 실행되어야 하는 경우가 발생한다. 주로 비동기 방식에서 일어나는 문제로 여러가지 이벤트가 접근하기 때문에 첫번째 함수의 결과값이 어떤 결과가 나올지 경우에 따라 분기처리를 해야하고 또 그에 따른 처리를 하고.. 다시 그에 따른 처리를 하고.. 이러다 보면 저러한 구조가 된다... 

                * 방지하려면

                    * 크게 2가지로 나뉜다.. 
                        * 동기화 함수를 이용. (현 프로그래밍 메타에 맞지 않는다. 동기화 함수 사용시 다른 이벤트들은 접근하지 못하고 끝날 때까지 대기해야 한다. - 이벤트 처리가 매우느림)

                        * Promise를 사용한다. 만능이 아니다. 이것 또한 번거로운 작업이다. 하지만 콜백지옥 보다는 훨씬 코딩이 간결하고 명시적이다.

            * Default, Rest 파라미터

            * 해체 할당, Spread 연산자

            * 템플릿 리터럴

            * 클래스 - 프로토타입에 문법적인 것이 추가되었을 뿐 그다지 개선되지 않았다는 등 여러 논란이 많다.

        * ECMA2015+

        * ECMA2016(ES7 2016년)

        * ECMA2017(ES8 2017년)

        * 현재 ECMA2017버전이 공식 릴리즈판이고 사실 ECMA2015까지 알면 최신버전까지 알고 있다고 생각하면 된다. (ECMA2015부터는 대규모 업데이트는 없었기 때문..)
        단 매우 빠른 속도 자바스크립트 환경이 변해가고 있으면 미리미리 알아두지 않으면 도저히 따라갈 수 없게 되는 것은 당연한 걸지도 모른다.. 자바스크립트는 더이상 프론트에서만 사용하는 언어도 아니도 그 기능이 국한되어 있는 언어도 아닌 여러가지 장점을 가지고 있고 무궁무진한 가능성이 있는 언어이다. 포기해서는 안 될 언어라고 생각한다. 미리 공부하즈아

        참고로 최근에 프론트 앤드 코딩방식은(여러 가지로 방법은 무궁무진하지만)
            
            * 프론트 영역 
                *  ECMA2015(ES6)
                *  npm - webpack - react.js 
                    * 코드편집기(visual studio code, atom)
                    * AngularJS 프레임워크 
                    * Spring
                *  npm - webpack - vue.js
                    * 코드편집기(visual studio code, atom)
                    * Spring
                
                * react는 라이브러리이고 vue.js나 Angular.js는
                프레임워크이다.. 즉 vue.js나 Angular.js는 자체적인 룰이 있다. react는 가져와서 사용하면 되는 라이브러리.
                Angular.js 프레임워크와는 연동해서 사용할 수 있다.
                    
            * 백엔드 영역
                * Java를 사용 - Spring, Eclipse
                * Javascript를 사용 - node.js
                * 그 외 다른 언어별 프레임워크 등등..

